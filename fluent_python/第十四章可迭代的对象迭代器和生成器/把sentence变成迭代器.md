### 把Sentence变成迭代器：坏主意
构建可迭代的对象和迭代器时经常会出现错误，
原因是混淆了二者。要知道，可迭代的对 象有个 __iter__ 方法，每次都实例化一个新的迭代器；
而迭代器要实现 __next__ 方 法，返回单个元素，此外还要实现 __iter__ 方法，返回迭代器本身。 
因此，迭代器可以迭代，但是可迭代的对象不是迭代器。 除了 __iter__ 方法之外，你可能还想在 Sentence 类中实现 __next__ 方法，让 Sentence 实例既是可迭代的对象，也是自身的迭代器。可是，这种想法非常糟糕。根据 有大量 Python 代码审查经验的 Alex Martelli 所说，这也是常见的反模式。 《设计模式：可复用面向对象软件的基础》一书讲解迭代器设计模式时，在“适用性”一节 中说： 
迭代器模式可用来： 
1. 访问一个聚合对象的内容而无需暴露它的内部表示 
2. 支持对聚合对象的多种遍历 
3. 为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）

为了“支持多种遍历”，必须能从同一个可迭代的实例中获取多个独立的迭代器，
而且各个 迭代器要能维护自身的内部状态，因此这一模式正确的实现方式是，
每次调用 iter(my_iterable) 都新建一个独立的迭代器。这就是为什么这个示例需要定义 SentenceIterator 类。