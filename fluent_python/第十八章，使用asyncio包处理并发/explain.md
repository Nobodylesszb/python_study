### 解释

##### asyncio.future 故意不阻塞

**yield from的用法**

- 在使用yield from 连接的多个协程最终必须有不是协成的调用方启动，调用方显示或隐式在最外层委托生成器上条用next(...)函数或者send()方法
- 链条中最内层的子生成器必须是简单的生成器。只使用yield或可迭代的对象

**在 asynico包的api中使用yield from时候，这两点都成立。弹药注意下列细节**

- 我们编写的协成链条始终把最外层委托生成器传给asyncio包api中的某个函数(如 loop,run_until_complete()驱动)，也就是说。使用asyncia包时，我们编写的代码不通过调用next()函数或者send()方法来驱动协成，这一点油asyncio包实现的事件循环去做
- 我们编写的携程链条最终通过yield from 把职责委托给asyncio包中的某个协成函数。或者协成方法。也就是说，最内层的子生成器是库中真正执行io操作的函数，而不是我们自己编写的函数

**概况起来就是说：**使用asyncio包时，我们编写的异步代码中包含由asyncio包本身驱动的协成，即(委托生成器)，而生成器最终把职责委托给asnycio包或者第三方库中的协程，这种方式相当于架起了管道，让asyncio事件循环驱动执行低层异步io操作的库函数